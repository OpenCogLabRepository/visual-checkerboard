#!/usr/bin/env python### checker.py written by Cameron Craddock####  Displays 8Hz reversing radial checkerboard, using a block designfrom VisionEgg import *start_default_logging(); watch_exceptions()from VisionEgg.Core import *from VisionEgg.Textures import *from VisionEgg.MoreStimuli import *from VisionEgg.Text import *from string import *import Image, ImageDraw#import OpenGL.GL as glimport os, sys import timeimport pygamefrom numpy import floorimport serial#################### input parameters #########################FIXATION = 0x43CHECKER  = 0x4f## parameters to describe the block design of the experiment# types of blocksblock_types     = [ FIXATION, CHECKER, FIXATION, CHECKER, FIXATION, CHECKER, FIXATION ] # duration of blocksblock_durations = [ 20.0,     20.0,    20.0,     20.0,    20.0,     20.0,    20.0 ] # secondsnum_blocks = len(block_types)expr_length = sum(block_durations)## parameters to describe checkerboard# 8Hz reversingduration_image = 0.125 # secondimage_scale_factor = 2.0/3.0 # desired image size in fraction of height# images that represent a full evolution of the checkerboard stimuliname_images = """full_radial_checker.pngfull_radial_checker_flip.png""" # define the responseskey_response = range (4)key_response[0] = 'b' # bluekey_response[1] = 'r' # red button on the button boxkey_response[2] = 'ESCAPE' # Esc key to quitkey_response[3] = '5' # trigger key#################### compute internal parameters ###################### obtain imagesprofile = []num_images = 0for i in name_images.split():	image = Image.open(i)	profile.append (Texture (image))   # convert image to texture object	num_images=num_images+1print "number of images",num_images####################################################### form the response event namefor i in range (len (key_response)):	key_response[i] = 'pygame.locals.K_'+key_response[i]##################### preparation ##################################### set screen parametersscreen=VisionEgg.Core.Screen(size=(1024,768),fullscreen=True)# use this and comment out above for visionegg dialogue #screen = get_default_screen ()screen.parameters.bgcolor = (0.5,0.5,0.5,0.0)## create introtexta = Text (text="Focus on the red point",            color=(1.0,1.0,1.0),            position=(screen.size[0]/2,screen.size[1]/2 + 60),	    font_size=30,	    anchor='center')textb = Text (text="",            color=(1.0,1.0,1.0),            position=(screen.size[0]/2,screen.size[1]/2+62.5),	    font_size=40,	    anchor='center')viewportIntro = Viewport (screen=screen, stimuli=[texta])## create presentation# create a red circle as a fixation pointfixation = FilledCircle (anchor   = 'center',  			 position = (screen.size[0]/2.0, screen.size[1]/2.0),  			 radius   = 5.0,  			 color    = (255, 0, 0)) # Draw it in red# create stimuli                           #color              = (0.5, 0.5, 0.5, 0.0),stimulus = TextureStimulus(mipmaps_enabled    = 0,                           texture            = profile[-1],                           texture_min_filter = gl.GL_LINEAR,                           size               = (2.0*screen.size[1]/3.0,2.0*screen.size[1]/3.0),                           position           = (screen.size[0]/2.0,screen.size[1]/2.0),                           anchor             = 'center')# create viewpointviewport = Viewport (screen=screen, stimuli=[fixation])##################### connect to serial ############################ ser = serial.Serial(0, 19200, timeout=1)##################### user-loop #################################### save timeframe_timer = VisionEgg.Core.FrameTimer()# counters and flags quit_now = 0start = Falseflag_start_presentation=Truecurrent_block = 0last_block = -1start_time = 0while not quit_now:	# SERIAL if there is a problem uncomment the next 3 lines	if start is False:		xx=''		xx=ser.read()		if xx:			print "received: ",xx		if xx == '5':			start=True        # process and events that might have been received	for event in pygame.event.get():		if event.type == pygame.locals.QUIT:			quit_now = True		elif event.type == pygame.locals.KEYDOWN:			if event.key == eval (key_response[-2]):				quit_now = True			elif event.key == eval (key_response[-1]):				start = True			elif event.key == eval (key_response[0]):				resp = 1			elif event.key == eval (key_response[1]):				resp = 2	## state machine describing experiment        # show instructions until triggered	if start is False:  # intro		screen.clear()		viewportIntro.draw ()	else:  # presentation				current_time = VisionEgg.time_func()		# if flag_start_presentation is true, this is 		# the first time through the logic		if flag_start_presentation is True:			flag_start_presentation = False			start_time = current_time			current_block = 0			# check to see if this block is finished			if current_time >= start_time + block_durations[current_block]:			current_block=current_block+1			start_time = current_time				if current_block >= num_blocks:			# experiment is over			quit_now = True		else:			# experiment is still running, determine stimuli			if block_types[current_block] == FIXATION:				viewport.parameters.stimuli = [fixation]			elif block_types[current_block] == CHECKER:				# determine which image to show				phase = int(floor((current_time-start_time)/duration_image)) % num_images				stimulus.parameters.texture = profile[phase]				viewport.parameters.stimuli = [stimulus, fixation] 			else:				fixation.parameters.color = (0,255,0)				viewport.parameters.stimuli = [fixation]		screen.clear ()		viewport.draw ()	swap_buffers ()	frame_timer.tick ()quit_now = 0while not quit_now:        # process and events that might have been received	for event in pygame.event.get():		if event.type == pygame.locals.QUIT:			quit_now = True		elif event.type == pygame.locals.KEYDOWN:			if event.key == eval (key_response[-2]):				quit_now = True